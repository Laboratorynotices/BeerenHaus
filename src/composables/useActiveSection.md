# useActiveSection

Компосабл для отслеживания активной секции на странице с автоматическим обнаружением и наблюдением за видимостью элементов.

## Обзор

`useActiveSection` решает одну из самых распространённых задач в современных веб-приложениях: автоматическое определение того, какая секция страницы в данный момент видна пользователю, и соответствующее обновление навигационного меню. Этот компосабл особенно полезен для одностраничных приложений (SPA) и лендинговых страниц с длинным контентом.

Основная сложность, которую решает данный компосабл, заключается в том, что во Vue.js приложениях DOM-дерево обновляется асинхронно, часто после выполнения хука `onMounted()`. Это означает, что простая попытка найти элементы сразу после монтирования компонента может не сработать, если контент загружается динамически или рендерится условно.

## Архитектурные принципы

### Singleton Pattern

Компосабл реализован как singleton, что означает наличие единого глобального состояния для всего приложения. Это критически важно для обеспечения консистентности: все компоненты, использующие `useActiveSection`, работают с одним и тем же состоянием активной секции. Вы можете вызывать `useActiveSection()` в любом количестве компонентов, и все они будут получать доступ к одному и тому же реактивному состоянию.

### Многоуровневая система наблюдения

Компосабл использует два типа Web API для максимальной надёжности:

**Intersection Observer API** служит основным механизмом отслеживания видимости элементов. Он настроен с параметрами, которые обеспечивают естественное поведение: элемент считается активным, когда он находится в средней части viewport (с отступами 20% сверху и снизу). Массив порогов срабатывания от 0 до 1 с шагом 0.1 позволяет точно определять процент видимости каждой секции.

**MutationObserver** отслеживает изменения в структуре DOM и автоматически переинициализирует систему наблюдения при добавлении или удалении элементов. Это особенно важно для SPA-приложений, где контент может изменяться после навигации между страницами или смены языка интерфейса.

### Система ожидания загрузки

Компосабл включает интеллектуальную систему ожидания появления элементов в DOM. Вместо простой проверки наличия элементов в один момент времени, он может:

- Ожидать загрузки конкретного списка секций
- Периодически сканировать DOM в поисках новых элементов с идентификаторами
- Автоматически прекращать поиск после определённого времени для экономии ресурсов

## Установка и базовое использование

### Подключение в компоненте

```vue
<script setup lang="ts">
import { useActiveSection } from "@/composables/useActiveSection";

// Получаем необходимые функции из единственного экземпляра
const { activeSection, isActive, scrollToSection, startAutoObserving } =
  useActiveSection();

// Запускаем автоматическое наблюдение при монтировании
onMounted(() => {
  startAutoObserving();
});
</script>

<template>
  <!-- Пример использования для навигационного меню -->
  <nav>
    <a
      href="#hero"
      :class="{ active: isActive('hero') }"
      @click="scrollToSection('hero')"
    >
      Главная
    </a>
    <a
      href="#about"
      :class="{ active: isActive('about') }"
      @click="scrollToSection('about')"
    >
      О нас
    </a>
  </nav>
</template>
```

### Использование с ожиданием конкретных секций

Если вы знаете, какие секции должны присутствовать на странице, вы можете передать их список для более эффективного ожидания:

```vue
<script setup lang="ts">
const { startAutoObserving } = useActiveSection();

onMounted(() => {
  // Ожидаем загрузки конкретных секций
  const expectedSections = ["hero", "about", "products", "contact"];
  startAutoObserving(expectedSections);
});
</script>
```

## API Reference

### Возвращаемые значения

#### `activeSection: Ref<string>`

Реактивная ссылка на идентификатор текущей активной секции. Обновляется автоматически при прокрутке страницы на основе видимости элементов.

```vue
<script setup lang="ts">
const { activeSection } = useActiveSection();

// Можно использовать в computed или watch
const currentSectionTitle = computed(() => {
  const titles = {
    hero: "Главная страница",
    about: "О компании",
    products: "Наши продукты",
  };
  return titles[activeSection.value] || "Неизвестная секция";
});
</script>
```

#### `isActive(sectionId: string): boolean`

Функция для проверки, является ли указанная секция активной в данный момент. Возвращает `true`, если переданный идентификатор соответствует текущей активной секции.

```vue
<template>
  <nav>
    <a :class="{ 'nav-active': isActive('hero') }">Главная</a>
    <a :class="{ 'nav-active': isActive('about') }">О нас</a>
  </nav>
</template>
```

#### `scrollToSection(sectionId: string): void`

Функция для плавной прокрутки к указанной секции. Автоматически учитывает высоту фиксированного заголовка (если элемент с id="header" существует) и добавляет дополнительный отступ в 20 пикселей для лучшего визуального позиционирования.

```vue
<script setup lang="ts">
const { scrollToSection } = useActiveSection();

const handleMenuClick = (event: Event, sectionId: string) => {
  event.preventDefault(); // Предотвращаем стандартное поведение ссылки
  scrollToSection(sectionId);
};
</script>
```

#### `startAutoObserving(expectedSections?: string[]): void`

Запускает автоматическую систему наблюдения за секциями. Принимает необязательный параметр `expectedSections` - массив идентификаторов секций, которые компосабл должен дождаться перед началом полноценного отслеживания.

При вызове без параметров компосабл немедленно начинает поиск всех элементов с идентификаторами в DOM и добавляет их к наблюдению. При передаче списка ожидаемых секций компосабл будет периодически проверять их наличие и регистрировать для наблюдения только после того, как все указанные элементы появятся в DOM.

#### `observeSection(sectionId: string): void`

Добавляет конкретную секцию к наблюдению. Полезно, когда вам нужно добавить отслеживание для элемента, который появляется в DOM после первоначальной инициализации.

```vue
<script setup lang="ts">
const { observeSection } = useActiveSection();

// Добавляем наблюдение для динамически созданного элемента
const addDynamicSection = () => {
  // ... код создания элемента
  nextTick(() => {
    observeSection("dynamic-section");
  });
};
</script>
```

#### `unobserveSection(sectionId: string): void`

Удаляет секцию из наблюдения. Используется для оптимизации производительности, когда определённые элементы больше не нуждаются в отслеживании.

#### `forceUpdate(): void`

Принудительно переинициализирует всю систему наблюдения. Особенно полезно после смены языка интерфейса или динамического обновления контента, когда DOM может быть значительно изменён.

```vue
<script setup lang="ts">
import { watch } from "vue";
import { useI18n } from "vue-i18n";

const { locale } = useI18n();
const { forceUpdate } = useActiveSection();

// Обновляем отслеживание при смене языка
watch(locale, () => {
  setTimeout(() => {
    forceUpdate();
  }, 500); // Даём время DOM обновиться
});
</script>
```

#### `cleanup(): void`

Полностью очищает все ресурсы компосабла: отключает все Observer'ы, очищает интервалы и сбрасывает состояние. Критически важно вызывать эту функцию в `onUnmounted` для предотвращения утечек памяти.

```vue
<script setup lang="ts">
const { cleanup } = useActiveSection();

onUnmounted(() => {
  cleanup();
});
</script>
```

## Настройка конфигурации

### Intersection Observer Parameters

Компосабл использует следующие настройки Intersection Observer, которые можно модифицировать в исходном коде:

```typescript
{
  root: null, // Viewport как корень наблюдения
  rootMargin: "-20% 0px -20% 0px", // Отступы от краёв viewport
  threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0] // Пороги срабатывания
}
```

**rootMargin: "-20% 0px -20% 0px"** означает, что элемент будет считаться "в зоне внимания" только когда он находится в средних 60% viewport. This создаёт более естественное ощущение активной секции, так как пользователь действительно фокусируется на содержимом в центральной части экрана.

**threshold array** позволяет получать точную информацию о проценте видимости каждого элемента, что особенно важно когда несколько секций одновременно видны на экране.

### Временные параметры

Компосабл использует несколько временных констант, которые можно настроить под специфику вашего приложения:

- **200ms** - интервал проверки при ожидании загрузки конкретных секций
- **500ms** - интервал повторного сканирования DOM в поисках новых элементов
- **100ms** - задержка перед переинициализацией после изменений в DOM
- **20 попыток** - максимальное количество попыток поиска элементов (итого 10 секунд)

## Практические примеры использования

### Комплексная навигация с breadcrumbs

```vue
<script setup lang="ts">
import { computed } from "vue";

const { activeSection, isActive, scrollToSection } = useActiveSection();

// Создаём breadcrumb навигацию на основе активной секции
const breadcrumbs = computed(() => {
  const sections = {
    hero: { title: "Главная", level: 1 },
    about: { title: "О компании", level: 2 },
    products: { title: "Продукты", level: 3 },
    contact: { title: "Контакты", level: 4 },
  };

  const current = sections[activeSection.value];
  if (!current) return [];

  return Object.entries(sections)
    .filter(([_, section]) => section.level <= current.level)
    .map(([id, section]) => ({ id, ...section }));
});

// Функция для определения прогресса прокрутки
const scrollProgress = computed(() => {
  const sections = ["hero", "about", "products", "contact"];
  const currentIndex = sections.indexOf(activeSection.value);
  return currentIndex >= 0 ? ((currentIndex + 1) / sections.length) * 100 : 0;
});
</script>

<template>
  <div class="navigation-complex">
    <!-- Индикатор прогресса -->
    <div class="progress-bar">
      <div class="progress-fill" :style="{ width: scrollProgress + '%' }"></div>
    </div>

    <!-- Breadcrumbs -->
    <nav class="breadcrumbs">
      <span
        v-for="crumb in breadcrumbs"
        :key="crumb.id"
        :class="{ active: crumb.id === activeSection }"
        @click="scrollToSection(crumb.id)"
      >
        {{ crumb.title }}
      </span>
    </nav>
  </div>
</template>
```

### Использование с динамическим контентом

```vue
<script setup lang="ts">
import { watch, ref } from "vue";

const { observeSection, unobserveSection, forceUpdate } = useActiveSection();

const dynamicSections = ref([]);

// Добавление новой секции во время выполнения
const addSection = async (sectionData) => {
  dynamicSections.value.push(sectionData);

  // Ожидаем рендера Vue
  await nextTick();

  // Регистрируем новую секцию для наблюдения
  observeSection(sectionData.id);
};

// Удаление секции
const removeSection = (sectionId) => {
  dynamicSections.value = dynamicSections.value.filter(
    (s) => s.id !== sectionId,
  );
  unobserveSection(sectionId);
};

// Полное обновление контента
const refreshContent = async () => {
  // Загружаем новые данные
  const newData = await fetchContentFromAPI();
  dynamicSections.value = newData;

  // Принудительно переинициализируем отслеживание
  await nextTick();
  forceUpdate();
};
</script>
```

### Интеграция с Vue Router

```vue
<script setup lang="ts">
import { useRouter } from "vue-router";
import { watch } from "vue";

const router = useRouter();
const { activeSection, scrollToSection } = useActiveSection();

// Синхронизация активной секции с URL hash
watch(activeSection, (newSection) => {
  if (newSection && window.location.hash !== `#${newSection}`) {
    // Обновляем URL без перезагрузки страницы
    router.replace({ hash: `#${newSection}` });
  }
});

// Обработка изменений в URL
watch(
  () => router.currentRoute.value.hash,
  (newHash) => {
    if (newHash) {
      const sectionId = newHash.slice(1); // Убираем символ #
      scrollToSection(sectionId);
    }
  },
);
</script>
```

## Производительность и оптимизация

### Рекомендации по производительности

При работе с большим количеством секций (более 20-30) рекомендуется учитывать следующие аспекты:

**Ограничение количества порогов срабатывания.** Если точность определения видимости не критична, можно уменьшить массив `threshold` до меньшего количества значений, например `[0, 0.5, 1.0]`.

**Использование debounce для частых обновлений.** При необходимости обработки очень частых изменений состояния можно добавить debounce к функции `updateActiveSection`.

**Ленивая инициализация для больших страниц.** На страницах с большим количеством контента можно инициализировать наблюдение только для видимых секций, добавляя остальные по мере прокрутки пользователя.

### Отладка и мониторинг

Для отладки работы компосабла можно добавить логирование:

```typescript
// В функции updateActiveSection
console.log("Активная секция изменилась:", {
  previous: activeSection.value,
  current: mostVisibleSection,
  visibility: Array.from(sectionVisibility.entries()),
});
```

## Совместимость и требования

### Поддержка браузеров

Компосабл требует поддержки следующих Web API:

- **Intersection Observer API** - поддерживается во всех современных браузерах (Chrome 58+, Firefox 55+, Safari 12.1+)
- **MutationObserver API** - широкая поддержка (IE 11+, все современные браузеры)
- **Set и Map** - нативная поддержка в ES6+ совместимых браузерах

### Зависимости

Компосабл требует Vue 3.x и использует следующие возможности фреймворка:

- Composition API (`ref`, `nextTick`)
- Реактивность Vue 3

### Полифиллы

Для поддержки старых браузеров может потребоваться полифилл для Intersection Observer:

```bash
npm install intersection-observer
```

```javascript
// В main.js или точке входа приложения
import "intersection-observer";
```

## Устранение неполадок

### Компосабл не находит секции

**Симптом:** Активная секция остаётся пустой, несмотря на наличие элементов на странице.

**Решение:** Убедитесь, что элементы имеют атрибут `id` и находятся внутри элемента `<main>`. Попробуйте увеличить временные задержки или использовать `forceUpdate()` после загрузки контента.

### Неточное определение активной секции

**Симптом:** Активной становится неправильная секция при прокрутке.

**Решение:** Проверьте параметр `rootMargin` в настройках Intersection Observer. Возможно, потребуется его корректировка в зависимости от высоты вашего заголовка или особенностей макета.

### Проблемы с производительностью

**Симптом:** Страница тормозит при прокрутке или работе с большим количеством секций.

**Решение:** Уменьшите количество порогов в массиве `threshold`, увеличьте интервалы проверок или добавьте debounce к критичным функциям.

### Утечки памяти

**Симптом:** Потребление памяти растёт при навигации между страницами.

**Решение:** Обязательно вызывайте `cleanup()` в хуке `onUnmounted` каждого компонента, который использует `useActiveSection`.

## Заключение

Компосабл `useActiveSection` представляет собой мощное и гибкое решение для отслеживания активных секций в современных веб-приложениях. Его архитектура учитывает специфику работы с Vue.js и асинхронной загрузкой контента, предоставляя разработчикам надёжный инструмент для создания интуитивной навигации.

Благодаря использованию современных Web API и продуманной системе ожидания загрузки элементов, компосабл работает стабильно даже в сложных сценариях с динамическим контентом и мультиязычностью. Singleton архитектура обеспечивает консистентность состояния во всём приложении, а богатый API позволяет легко интегрировать функциональность в любые компоненты навигации.
