# useScrollAnimator

Vue 3 композабл для создания плавных анимаций, запускающихся при прокрутке страницы, с поддержкой псевдоэлементов (::before и ::after). Эта библиотека предоставляет удобный API для анимации элементов при их появлении во viewport с широкими возможностями настройки направления, времени, трансформаций и работы с псевдоэлементами.

## Возможности

Композабл предоставляет мощный набор инструментов для создания современных веб-анимаций. **Анимации, запускающиеся прокруткой** позволяют элементам плавно появляться по мере того, как пользователь исследует контент страницы. **Поддержка псевдоэлементов** открывает возможности для создания сложных многослойных эффектов, где ::before и ::after элементы могут анимироваться независимо от основного элемента.

Особенно важной особенностью является **поддержка множественных анимаций на одном элементе**. Это означает, что вы можете применить разные анимации к самому элементу и его псевдоэлементам, создавая богатые визуальные эффекты. **Гибкое позиционирование** позволяет элементам "влетать" с любой стороны экрана, а **продвинутые трансформации** включают поддержку поворотов, масштабирования и смещений.

Композабл **оптимизирован для производительности** благодаря использованию IntersectionObserver и requestAnimationFrame, **совместим с SSR** и полностью поддерживает **TypeScript** с комплексными определениями типов.

## Установка

Композабл работает с Vue 3:

```bash
npm install vue
```

Скопируйте файл `useScrollAnimator.ts` в ваш проект и импортируйте его там, где необходимо.

## Базовое использование

Начнем с простейшего примера, чтобы понять основные концепции. Представьте, что у вас есть карточки на странице, которые должны плавно появляться при прокрутке. В Vue 3 мы используем Composition API, который дает нам большую гибкость в организации логики компонента:

```javascript
<script setup>
import { onMounted } from 'vue'
import { useScrollAnimator } from './composables/useScrollAnimator'

// Инициализируем композабл - это создает экземпляр аниматора
// со стандартными настройками, которые мы можем переопределить
const { animate } = useScrollAnimator()

onMounted(() => {
  // Базовая анимация - элементы всплывают снизу вверх
  // Здесь мы используем все настройки по умолчанию
  animate('.fade-in')

  // Кастомная анимация справа с ускоренным временем
  // Этот пример показывает, как переопределить отдельные параметры
  animate('.slide-right', {
    origin: 'right',    // Элементы появляются справа
    duration: 1000      // Анимация в два раза быстрее стандартной
  })
})
</script>

<template>
  <div class="page-content">
    <!-- Эти карточки будут анимироваться стандартно -->
    <div class="card fade-in">Первая карточка</div>
    <div class="card fade-in">Вторая карточка</div>

    <!-- А эти получат специальную анимацию справа -->
    <div class="special-card slide-right">Особенная карточка</div>
  </div>
</template>
```

В этом примере мы видим несколько важных концепций. Во-первых, композабл инициализируется один раз в начале компонента, что создает единый экземпляр аниматора для всех анимаций в этом компоненте. Во-вторых, мы вызываем `animate` только после того, как компонент монтирован и элементы гарантированно существуют в DOM. Элементы с классом `.fade-in` получат стандартное поведение, а `.slide-right` - индивидуальные настройки.

## Справочник API

### useScrollAnimator(globalOptions?)

Создает экземпляр аниматора с опциональными глобальными настройками, которые применяются ко всем анимациям, если не переопределены локально.

Глобальные настройки помогают поддерживать единообразие анимаций на всем сайте. Представим ситуацию, где дизайн-система вашего проекта требует, чтобы все анимации были чуть быстрее стандартных и элементы появлялись преимущественно слева. Вместо того чтобы указывать эти параметры в каждом вызове `animate`, мы можем установить их глобально:

```javascript
<script setup>
import { onMounted } from 'vue'
import { useScrollAnimator } from './composables/useScrollAnimator'

// Создаем аниматор с глобальными настройками
// Эти параметры будут применяться ко всем анимациям,
// если они не переопределены локально
const { animate } = useScrollAnimator({
  duration: 1500,    // Длительность анимации по умолчанию (быстрее стандартной)
  origin: 'left',    // Направление появления по умолчанию (слева)
  delay: 200         // Задержка по умолчанию перед началом (короче стандартной)
})

onMounted(() => {
  // Эта анимация использует все глобальные настройки
  animate('.standard-elements')

  // А эта переопределяет только direction, остальное берет из глобальных
  animate('.special-elements', { origin: 'top' })
})
</script>
```

### animate(selector, options?)

Применяет анимацию, запускающуюся прокруткой, к элементам, соответствующим CSS селектору.

Этот метод является основным инструментом для создания анимаций. Он принимает CSS селектор и объект с настройками анимации. Давайте разберем детально, как это работает на практике:

```javascript
<script setup>
import { onMounted } from 'vue'
import { useScrollAnimator } from './composables/useScrollAnimator'

const { animate } = useScrollAnimator()

onMounted(() => {
  // Комплексная анимация с полным набором параметров
  // Этот пример демонстрирует все доступные возможности
  animate('.my-elements', {
    origin: 'top',      // Направление: элементы "падают" сверху
    distance: '100px',  // Начальное смещение: на 100 пикселей выше финальной позиции
    duration: 2000,     // Длительность: анимация займет 2 секунды
    delay: 500,         // Задержка: начнется через полсекунды после попадания в viewport
    reset: true,        // Повторение: будет заново анимироваться при прокрутке назад
    pseudo: 'before',   // Цель: анимируется псевдоэлемент ::before, а не сам элемент
    scale: 0.8,         // Масштаб: псевдоэлемент начинает в уменьшенном виде
    rotate: {           // Поворот: начальные углы поворота создают эффект "кувырка"
      x: 45,            // Наклон вперед на 45 градусов
      y: 0,             // Без бокового наклона
      z: 90             // Поворот на четверть оборота по часовой стрелке
    }
  })
})
</script>

<template>
  <div>
    <!-- Элементы, которые будут анимироваться -->
    <!-- Помните, что анимируется ::before псевдоэлемент -->
    <div class="my-elements">Первый элемент</div>
    <div class="my-elements">Второй элемент</div>
  </div>
</template>

<style>
/* Не забудьте задать базовые стили для псевдоэлемента */
.my-elements::before {
  content: "";
  position: absolute;
  width: 100%;
  height: 100%;
  background: linear-gradient(45deg, #667eea, #764ba2);
  border-radius: 8px;
  z-index: -1;
  /* Анимационные свойства будут установлены композаблом */
}
</style>
```

## Параметры анимации

Понимание каждого параметра поможет вам создать именно тот анимационный эффект, который вы задумали.

### origin: "top" | "right" | "bottom" | "left"

**По умолчанию: "bottom"**

Этот параметр управляет тем, с какой стороны элементы "влетают" на свои финальные позиции. Думайте об этом как о точке старта путешествия элемента к его окончательному местоположению. Когда вы выбираете `"bottom"`, элементы начинают свой путь ниже их финальной позиции и скользят вверх. `"Top"` заставляет элементы начинать выше и скользить вниз. `"Left"` и `"right"` работают аналогично для горизонтального движения.

Выбор направления влияет на восприятие пользователем контента. Анимация снизу вверх создает ощущение "всплытия" или "роста", что хорошо подходит для контента, который должен привлечь внимание. Горизонтальные анимации создают динамику и могут направлять взгляд пользователя.

### distance: string

**По умолчанию: "60px"**

Определяет, насколько далеко от финальной позиции элементы начинают свою анимацию. Обязательно указывайте единицы измерения (px, rem, %, vh и так далее). Большие расстояния создают более драматичные эффекты входа, маленькие — более тонкие.

```javascript
animate(".dramatic", { distance: "200px" }); // Очень драматичное появление
animate(".subtle", { distance: "20px" }); // Тонкое движение
```

Выбор расстояния зависит от размера ваших элементов и желаемого визуального воздействия. Для больших героических секций можно использовать большие расстояния, для небольших элементов интерфейса — минимальные.

### duration: number

**По умолчанию: 2000**

Длительность анимации в миллисекундах. Более длинные анимации создают ощущение спокойствия и элегантности, более короткие — энергичности и отзывчивости. Стандартные 2 секунды обычно хорошо подходят для большинства случаев, но вы можете экспериментировать в зависимости от контекста.

### delay: number

**По умолчанию: 300**

Задержка перед началом анимации в миллисекундах. Этот параметр особенно полезен для создания каскадных эффектов, когда несколько элементов анимируются последовательно. Например, карточки в сетке могут появляться одна за другой с небольшими интервалами.

### reset: boolean

**По умолчанию: false**

Когда установлено в `true`, элементы возвращаются в скрытое состояние при прокрутке назад и снова анимируются при прокрутке вниз. Когда `false`, элементы анимируются один раз и остаются видимыми. Повторяющиеся анимации подходят для случаев, когда вы хотите поддерживать визуальную динамику при навигации по странице.

### pseudo: "before" | "after" | null

**По умолчанию: null**

Определяет, какую часть элемента анимировать. Это одна из самых мощных возможностей композабла:

- `null` анимирует сам элемент
- `"before"` анимирует псевдоэлемент ::before
- `"after"` анимирует псевдоэлемент ::after

Возможность анимировать псевдоэлементы открывает огромные творческие возможности. Вы можете создавать слоистые анимации, где разные части одного элемента имеют независимое время и эффекты анимации.

### scale: number

**По умолчанию: 1**

Начальный масштаб для псевдоэлементов. Значения меньше 1 заставляют элементы начинать в уменьшенном виде, больше 1 — в увеличенном. Этот параметр влияет только на псевдоэлементы, не на основной элемент, что позволяет создавать эффекты "роста" или "сжатия" декоративных элементов.

### rotate: { x?: number; y?: number; z?: number }

**По умолчанию: { x: 0, y: 0, z: 0 }**

Начальные углы поворота в градусах для каждой оси. Создает эффекты вращения или наклона при анимации элементов. Поворот по оси `x` создает наклон вперед/назад, по оси `y` — влево/вправо, по оси `z` — вращение по часовой стрелке. Комбинирование поворотов по разным осям создает сложные трехмерные эффекты.

## Анимации псевдоэлементов

Одной из самых мощных возможностей композабла является способность независимо анимировать псевдоэлементы. Это открывает возможности для создания сложных слоистых эффектов, где разные части одного элемента анимируются с разным временем и параметрами.

### Настройка псевдоэлементов

Сначала убедитесь, что ваши псевдоэлементы имеют базовую стилизацию в CSS. Композабл управляет только свойствами анимации (`opacity`, `transform`, `transition`), но размеры, позиционирование и внешний вид остаются в вашей ответственности:

```css
.hero__images::before {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  border-radius: 8px;
  /* content: ""; и свойства анимации обрабатываются композаблом */
}

.hero__images::after {
  position: absolute;
  top: 10px;
  left: 10px;
  right: 10px;
  bottom: 10px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
}
```

### Анимация нескольких псевдоэлементов

Композабл поддерживает множественные анимации на одном элементе, что позволяет создавать сложные слоистые эффекты. Представим компонент героической секции, где нужно создать многослойный визуальный эффект:

```javascript
<script setup>
import { onMounted } from 'vue'
import { useScrollAnimator } from './composables/useScrollAnimator'

const { animate } = useScrollAnimator()

onMounted(() => {
  // Анимируем псевдоэлемент ::before - создаем фоновый эффект
  // Этот слой будет всплывать снизу, создавая основу композиции
  animate('.hero__images', {
    pseudo: 'before',     // Работаем с фоновым псевдоэлементом
    origin: 'bottom',     // Всплывает снизу - классический эффект "роста"
    duration: 1500        // Умеренная скорость для плавного появления
  })

  // Анимируем псевдоэлемент ::after с задержкой для каскадного эффекта
  // Этот декоративный слой появится позже, создавая динамику
  animate('.hero__images', {
    pseudo: 'after',      // Работаем с декоративным псевдоэлементом
    delay: 4000,          // Большая задержка - эффект "сюрприза"
    origin: 'top',        // Падает сверху - контрастирует с первым слоем
    duration: 2000        // Медленнее первого для создания ритма
  })

  // Можно также анимировать основной элемент
  // Содержимое появляется со стороны, создавая третий слой движения
  animate('.hero__images', {
    origin: 'left',       // Боковое движение добавляет разнообразие
    delay: 500,           // Небольшая задержка - появляется после фона, но до декора
    duration: 1000        // Быстрое появление - акцент на контенте
  })
})
</script>

<template>
  <div class="hero">
    <div class="hero__images">
      <img src="hero-image.jpg" alt="Главное изображение" />
      <h2>Заголовок героической секции</h2>
      <p>Описание, которое дополняет изображение</p>
    </div>
  </div>
</template>

<style>
.hero__images {
  position: relative;
  /* Основные стили элемента */
}

.hero__images::before {
  content: "";
  position: absolute;
  top: -10px;
  left: -10px;
  right: -10px;
  bottom: -10px;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  border-radius: 12px;
  z-index: -1;
  /* Композабл управляет только анимацией, стили задаем мы */
}

.hero__images::after {
  content: "";
  position: absolute;
  top: 10px;
  left: 10px;
  right: 10px;
  bottom: 10px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 6px;
  backdrop-filter: blur(10px);
  z-index: 1;
}
</style>
```

````

Каждая анимация выполняется независимо, создавая богатые многослойные визуальные эффекты. Это особенно эффектно для создания фонов, декоративных элементов и сложных интерфейсных компонентов.

## Продвинутые примеры

### Каскадные анимации карточек

Создание волнового эффекта требует понимания того, как пользователи воспринимают движение на экране. Когда элементы появляются все одновременно, это может выглядеть хаотично. Каскадный эффект создает ощущение упорядоченности и направляет взгляд пользователя по странице:

```javascript
<script setup>
import { onMounted } from 'vue'
import { useScrollAnimator } from './composables/useScrollAnimator'

const { animate } = useScrollAnimator()

onMounted(() => {
  // Первая волна карточек - нечетные элементы появляются слева
  // Этот подход создает зигзагообразный паттерн движения
  animate('.card:nth-child(odd)', {
    origin: 'left',     // Нечетные карточки "выезжают" слева
    delay: 200,         // Короткая задержка для быстрого старта
    duration: 1000      // Умеренная скорость для плавности
  })

  // Вторая волна с большей задержкой - четные элементы справа
  // Задержка создает эффект "диалога" между группами карточек
  animate('.card:nth-child(even)', {
    origin: 'right',    // Четные карточки отвечают справа
    delay: 600,         // Большая задержка создает ритмичность
    duration: 1000      // Та же скорость для единообразия
  })

  // Можно добавить третий слой для заголовков карточек
  // Это создает дополнительную глубину анимации
  animate('.card__title', {
    origin: 'top',      // Заголовки "падают" сверху
    delay: 800,         // Появляются после основной карточки
    duration: 600       // Быстрее основной анимации для акцента
  })
})
</script>

<template>
  <div class="cards-grid">
    <div class="card" v-for="card in cards" :key="card.id">
      <h3 class="card__title">{{ card.title }}</h3>
      <p class="card__content">{{ card.description }}</p>
    </div>
  </div>
</template>
````

Такой подход создает динамичное появление контента, где элементы как будто "разговаривают" друг с другом, появляясь в ритмичном порядке. Пользователь видит не хаотичное движение, а организованную последовательность, которая ведет его взгляд через контент.

### Сложный слоистый эффект

Построение сложных анимаций требует понимания того, как разные элементы взаимодействуют друг с другом во времени. В этом примере мы создадим трехслойную композицию, где каждый элемент выполняет свою роль в общей анимационной истории:

```javascript
<script setup>
import { onMounted } from 'vue'
import { useScrollAnimator } from './composables/useScrollAnimator'

const { animate } = useScrollAnimator()

onMounted(() => {
  // Первый слой - фоновый эффект, создает основу для всей композиции
  // Фон должен появиться первым, чтобы создать сцену для остального контента
  animate('.feature-box', {
    pseudo: 'before',       // Используем ::before как фоновый слой
    origin: 'bottom',       // Всплывает снизу - создает ощущение "роста" или "строительства"
    distance: '150px',      // Большое расстояние для драматичного эффекта
    duration: 2000,         // Медленная анимация для плавного появления основы
    scale: 0.9              // Начинает чуть меньше, потом "расцветает"
  })

  // Второй слой - декоративный элемент, добавляет динамику и интерес
  // Появляется позже, создавая эффект "украшения" уже существующей основы
  animate('.feature-box', {
    pseudo: 'after',        // ::after как декоративный слой поверх основы
    origin: 'top',          // Падает сверху - контрастирует с основой
    delay: 1000,            // Задержка позволяет фону сначала установиться
    duration: 1500,         // Быстрее фона, но медленнее контента
    rotate: { z: 180 },     // Поворот на пол-оборота создает эффект "кувырка"
    scale: 0.5              // Начинает совсем маленьким, потом увеличивается
  })

  // Третий слой - основной контент, самый важный элемент
  // Появляется с умеренной задержкой, чтобы пользователь мог оценить декорации
  animate('.feature-box', {
    origin: 'left',         // Скользит слева - классическое направление для чтения
    delay: 500,             // Небольшая задержка, чтобы не перебивать фон
    duration: 1800          // Средняя скорость - не слишком быстро, не слишком медленно
  })

  // Четвертый слой - дополнительные детали (например, иконки или кнопки)
  // Появляются последними, создавая финальный штрих композиции
  animate('.feature-box__icon', {
    origin: 'top',          // Падают сверху, как акценты
    delay: 1200,            // Появляются после основного контента
    duration: 800,          // Быстро, чтобы не затягивать анимацию
    scale: 0.3              // Начинают очень маленькими для эффекта "взрыва"
  })
})
</script>

<template>
  <div class="features">
    <div class="feature-box" v-for="feature in features" :key="feature.id">
      <div class="feature-box__icon">
        <svg><!-- Иконка --></svg>
      </div>
      <h3 class="feature-box__title">{{ feature.title }}</h3>
      <p class="feature-box__description">{{ feature.description }}</p>
    </div>
  </div>
</template>

<style>
.feature-box {
  position: relative;
  padding: 2rem;
  /* Основные стили контейнера */
}

/* Фоновый слой - создает базу для композиции */
.feature-box::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 16px;
  z-index: -2;
  /* Анимационные свойства управляются композаблом */
}

/* Декоративный слой - добавляет глубину и интерес */
.feature-box::after {
  content: "";
  position: absolute;
  top: 10px;
  left: 10px;
  right: 10px;
  bottom: 10px;
  background: rgba(255, 255, 255, 0.1);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  backdrop-filter: blur(10px);
  z-index: -1;
}

.feature-box__icon {
  position: relative;
  z-index: 2;
  /* Убеждаемся, что иконки появляются поверх всех слоев */
}
</style>
```

Этот многослойный подход создает богатую анимационную композицию, где каждый элемент входит в свое время и вносит свой вклад в общую историю. Фон создает сцену, декоративные элементы добавляют интерес, основной контент доставляет информацию, а детали завершают картину. Такая последовательность не только визуально привлекательна, но и помогает пользователю постепенно воспринять и обработать всю информацию.

### Повторяющиеся анимации

В некоторых случаях имеет смысл создавать элементы, которые заново анимируются каждый раз при попадании во viewport. Это особенно полезно для длинных страниц или интерактивных элементов, где пользователь может прокручивать контент вверх и вниз несколько раз:

```javascript
<script setup>
import { onMounted } from 'vue'
import { useScrollAnimator } from './composables/useScrollAnimator'

const { animate } = useScrollAnimator()

onMounted(() => {
  // Основные повторяющиеся элементы
  // Каждый раз, когда пользователь прокручивает к ним, они снова анимируются
  animate('.repeating-element', {
    reset: true,          // Ключевой параметр - включает повторение анимации
    origin: 'bottom',     // Классическое направление снизу
    duration: 1000,       // Умеренная скорость, чтобы не надоедать при повторах
    delay: 100            // Минимальная задержка для отзывчивости
  })

  // Можно создать разные группы повторяющихся элементов
  // Например, боковые элементы с горизонтальным движением
  animate('.sidebar-repeating', {
    reset: true,          // Также повторяются
    origin: 'left',       // Боковое движение добавляет разнообразие
    duration: 800,        // Чуть быстрее основных элементов
    delay: 50             // Минимальная задержка для быстрого отклика
  })
})
</script>

<template>
  <div class="long-page">
    <!-- Основной контент, который будет повторно анимироваться -->
    <section class="content-section">
      <div class="repeating-element">
        <h2>Заголовок секции</h2>
        <p>Контент, который всегда реагирует на прокрутку</p>
      </div>
    </section>

    <!-- Боковые элементы -->
    <aside class="sidebar-repeating">
      <div class="widget">Боковой виджет</div>
    </aside>
  </div>
</template>
```

Повторяющиеся анимации создают живую, отзывчивую атмосферу на странице. Пользователи получают визуальную обратную связь при навигации, что делает интерфейс более интерактивным и приятным в использовании. Однако важно использовать этот эффект разумно - слишком активные повторяющиеся анимации могут отвлекать от контента.

## Соображения производительности

Композабл спроектирован с учетом производительности и использует современные веб-технологии для обеспечения плавных анимаций.

**IntersectionObserver** используется для отслеживания появления элементов во viewport. Важно понимать, что создается только один экземпляр observer для всех элементов, что минимизирует использование ресурсов по сравнению с созданием множественных наблюдателей.

**requestAnimationFrame** обеспечивает синхронизацию триггеров анимации с частотой обновления браузера. Это гарантирует плавность анимаций и предотвращает проблемы с производительностью, которые могут возникнуть при прямом изменении стилей.

**Автоматическая очистка ресурсов** происходит при размонтировании компонентов. Наблюдатели отключаются, а ресурсы освобождаются для предотвращения утечек памяти. Это особенно важно в SPA приложениях, где компоненты могут создаваться и уничтожаться многократно.

**Эффективное управление состоянием** достигается использованием `WeakMap` и `Map` для отслеживания элементов. Это позволяет сборщику мусора автоматически очищать данные, когда элементы удаляются из DOM.

## Поддержка браузеров

Композабл работает во всех современных браузерах, поддерживающих IntersectionObserver API (все браузеры начиная с 2017 года), CSS Custom Properties (CSS переменные) и возможности ES6+ JavaScript.

Для старых браузеров может потребоваться полифилл для IntersectionObserver, но в большинстве современных проектов это не является проблемой.

## Поддержка TypeScript

Композабл полностью типизирован с комплексными определениями TypeScript. Все опции проверяются на типы, а ваша IDE предоставит полную поддержку автодополнения для всех параметров конфигурации. Это помогает избежать ошибок конфигурации и ускоряет разработку.

## Решение проблем

**Элементы не анимируются**: Проверьте, что ваш CSS селектор соответствует существующим элементам в DOM на момент вызова `animate()`. Элементы должны существовать до вызова метода анимации.

**Псевдоэлементы не видны**: Убедитесь, что ваш CSS включает базовое позиционирование и размеры для псевдоэлементов. Композабл обрабатывает только свойства анимации, но не макет.

**Анимации выглядят прерывисто**: Попробуйте уменьшить количество одновременно анимирующихся элементов или увеличить длительность анимации для более плавных эффектов.

**Множественные вызовы перекрывают друг друга**: Улучшенная версия корректно обрабатывает множественные вызовы `animate()` на одном элементе, но убедитесь, что используете последнюю версию, если возникают проблемы.
